<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>import os
import pya

iconPath = str(os.path.dirname(__file__)) + "/Icon/%s.png"

class AlignWidget(pya.QWidget):
    def __init__(self, alignUI = True, snapUI = True, rotateUI = True, booleanUI = False, distributeUI = True, utilUI = True, parent = None):
        super(AlignWidget, self).__init__(parent)  
        self.firstObj = None
        self.initUI(alignUI, snapUI, rotateUI, booleanUI, distributeUI, utilUI)
        
    def initUI(self, alignUI, snapUI, rotateUI, booleanUI, distributeUI, utilUI):
        columnSpacing            = 20
        rowSpacing               = 20
        categorySpacing          = 20
        self.grabRuler           = None
        self.grabShadows         = []
        self.grabTheme           = {}
        self.alignmentLB         = TitleLB("Alignment")
        self.snapLB              = TitleLB("Snap")
        self.rotationLB          = TitleLB("Rotate")
        self.booleanLB           = TitleLB("Boolean")
        self.distributeLB        = TitleLB("Distribute")
        self.utilLB              = TitleLB("Utilities")
        self.configLB            = TitleLB("Configuration")       
        
        self.alignLeftPB         = SquarePB(iconPath % "alignLeft",         lambda : self.alignSnap("alignLeft",         self.useVisibleLayers(), self.allowAnnoAlign()))
        self.alignCenterPB       = SquarePB(iconPath % "alignCenter",       lambda : self.alignSnap("alignCenter",       self.useVisibleLayers(), self.allowAnnoAlign()))
        self.alignRightPB        = SquarePB(iconPath % "alignRight",        lambda : self.alignSnap("alignRight",        self.useVisibleLayers(), self.allowAnnoAlign()))
        
        self.alignTopPB          = SquarePB(iconPath % "alignTop",          lambda : self.alignSnap("alignTop",          self.useVisibleLayers(), self.allowAnnoAlign()))
        self.alignMiddlePB       = SquarePB(iconPath % "alignMiddle",       lambda : self.alignSnap("alignMiddle",       self.useVisibleLayers(), self.allowAnnoAlign()))
        self.alignBottomPB       = SquarePB(iconPath % "alignBottom",       lambda : self.alignSnap("alignBottom",       self.useVisibleLayers(), self.allowAnnoAlign()))

        self.alignTopLeftPB      = SquarePB(iconPath % "alignTopLeft",      lambda : self.alignSnap("alignTopLeft",      self.useVisibleLayers(), self.allowAnnoAlign()))
        self.alignTopCenterPB    = SquarePB(iconPath % "alignTopCenter",    lambda : self.alignSnap("alignTopCenter",    self.useVisibleLayers(), self.allowAnnoAlign()))
        self.alignTopRightPB     = SquarePB(iconPath % "alignTopRight",     lambda : self.alignSnap("alignTopRight",     self.useVisibleLayers(), self.allowAnnoAlign()))
        
        self.alignMiddleLeftPB   = SquarePB(iconPath % "alignMiddleLeft",   lambda : self.alignSnap("alignMiddleLeft",   self.useVisibleLayers(), self.allowAnnoAlign()))
        self.alignMiddleCenterPB = SquarePB(iconPath % "alignMiddleCenter", lambda : self.alignSnap("alignMiddleCenter", self.useVisibleLayers(), self.allowAnnoAlign()))
        self.alignMiddleRightPB  = SquarePB(iconPath % "alignMiddleRight",  lambda : self.alignSnap("alignMiddleRight",  self.useVisibleLayers(), self.allowAnnoAlign()))
        
        self.alignBottomLeftPB   = SquarePB(iconPath % "alignBottomLeft",   lambda : self.alignSnap("alignBottomLeft",   self.useVisibleLayers(), self.allowAnnoAlign()))
        self.alignBottomCenterPB = SquarePB(iconPath % "alignBottomCenter", lambda : self.alignSnap("alignBottomCenter", self.useVisibleLayers(), self.allowAnnoAlign()))
        self.alignBottomRightPB  = SquarePB(iconPath % "alignBottomRight",  lambda : self.alignSnap("alignBottomRight",  self.useVisibleLayers(), self.allowAnnoAlign()))
        
        self.transByRulerPB      = SquarePB(iconPath % "transByRuler",      lambda : self.transByRuler(), hoverFunction = lambda : self.attemptGrabRuler())
         
        self.snapLeftPB          = SquarePB(iconPath % "snapLeft",          lambda : self.alignSnap("snapLeft",          self.useVisibleLayers(), self.allowAnnoAlign()))
        self.snapRightPB         = SquarePB(iconPath % "snapRight",         lambda : self.alignSnap("snapRight",         self.useVisibleLayers(), self.allowAnnoAlign()))
        
        self.snapTopPB           = SquarePB(iconPath % "snapTop",           lambda : self.alignSnap("snapTop",           self.useVisibleLayers(), self.allowAnnoAlign()))
        self.snapBottomPB        = SquarePB(iconPath % "snapBottom",        lambda : self.alignSnap("snapBottom",        self.useVisibleLayers(), self.allowAnnoAlign()))
        self.snapDummyPB         = SquarePB(iconPath % "snapDummy",         lambda : self.dummy())
        
        self.snapTopLeftPB       = SquarePB(iconPath % "snapTopLeft",       lambda : self.alignSnap("snapTopLeft",       self.useVisibleLayers(), self.allowAnnoAlign()))
        self.snapTopRightPB      = SquarePB(iconPath % "snapTopRight",      lambda : self.alignSnap("snapTopRight",      self.useVisibleLayers(), self.allowAnnoAlign()))
        
        self.snapBottomLeftPB    = SquarePB(iconPath % "snapBottomLeft",    lambda : self.alignSnap("snapBottomLeft",    self.useVisibleLayers(), self.allowAnnoAlign()))
        self.snapBottomRightPB   = SquarePB(iconPath % "snapBottomRight",   lambda : self.alignSnap("snapBottomRight",   self.useVisibleLayers(), self.allowAnnoAlign()))
        
        self.distributeHPB       = SquarePB(iconPath % "distributeH",       lambda : self.distrubuteH(True, self.useVisibleLayers()))
        self.distributeVPB       = SquarePB(iconPath % "distributeV",       lambda : self.distrubuteV(True, self.useVisibleLayers()))
        
        self.booleanMergePB      = SquarePB(iconPath % "booleanMerge")
        self.booleanIntersectPB  = SquarePB(iconPath % "booleanIntersect")
        self.booleanSubstractPB  = SquarePB(iconPath % "booleanSubstract")
        self.booleanSeperatePB   = SquarePB(iconPath % "booleanSeperate")
        
        self.rotateCCW90PB       = SquarePB(iconPath % "rotateCCW90",       lambda : self.rotateFlipShape( 90, False, False, self.rotateByEachCenter()))
        self.rotateCW90PB        = SquarePB(iconPath % "rotateCW90",        lambda : self.rotateFlipShape(-90, False, False, self.rotateByEachCenter()))
        self.flipHorizontalPB    = SquarePB(iconPath % "flipHorizontal",    lambda : self.rotateFlipShape(  0,  True, False, self.rotateByEachCenter()))
        self.flipVerticalPB      = SquarePB(iconPath % "flipVertical",      lambda : self.rotateFlipShape(  0, False,  True, self.rotateByEachCenter()))

        self.drawShadowPB        = SquarePB(iconPath % "drawShadow",        lambda : self.grabSelectedShadow())
        

        self.configUseVisCB      = pya.QCheckBox ("Use visible only for align/snap")
        self.configUseAnnoCB     = pya.QCheckBox ("Allow Align to Ruler")
        self.configRotEachCB     = pya.QCheckBox ("Rotate each shape center")

        self.donePB              = pya.QPushButton("Done")

        self.alignGrid           = pya.QGridLayout()
        self.snapGrid            = pya.QGridLayout()
        self.rotateGrid          = pya.QGridLayout()
        self.boolGrid            = pya.QGridLayout()
        self.distGrid            = pya.QGridLayout()
        self.configGrid          = pya.QGridLayout()
        self.utilGrid            = pya.QGridLayout()
        self.bottomBarGrid       = pya.QGridLayout()
        self.grid                = pya.QGridLayout()

        
        
        self.donePB.clicked(lambda : self.close())

        self.alignGrid.addWidget(self.alignmentLB,         0, 0, 1, 5)
        self.alignGrid.addWidget(self.alignTopLeftPB,      1, 2, 1, 1)
        self.alignGrid.addWidget(self.alignTopCenterPB,    1, 3, 1, 1)
        self.alignGrid.addWidget(self.alignTopRightPB,     1, 4, 1, 1)
        self.alignGrid.addWidget(self.alignTopPB,          1, 0, 1, 1)
             
        self.alignGrid.addWidget(self.alignMiddleLeftPB,   2, 2, 1, 1)
        self.alignGrid.addWidget(self.alignMiddleCenterPB, 2, 3, 1, 1)
        self.alignGrid.addWidget(self.alignMiddleRightPB,  2, 4, 1, 1)
        self.alignGrid.addWidget(self.alignMiddlePB,       2, 0, 1, 1)
             
        self.alignGrid.addWidget(self.alignBottomLeftPB,   3, 2, 1, 1)
        self.alignGrid.addWidget(self.alignBottomCenterPB, 3, 3, 1, 1)
        self.alignGrid.addWidget(self.alignBottomRightPB,  3, 4, 1, 1)
        self.alignGrid.addWidget(self.alignBottomPB,       3, 0, 1, 1)
             
        self.alignGrid.addWidget(self.alignLeftPB,         5, 2, 1, 1)
        self.alignGrid.addWidget(self.alignCenterPB,       5, 3, 1, 1)
        self.alignGrid.addWidget(self.alignRightPB,        5, 4, 1, 1)
        self.alignGrid.addWidget(self.transByRulerPB,      5, 0, 1, 1)
        
        
        self.alignGrid.setColumnMinimumWidth(1, columnSpacing)
        self.alignGrid.setRowMinimumHeight(4, rowSpacing)        
        self.alignGrid.setRowStretch(6, 1)

        
        self.snapGrid.addWidget(self.snapLB,               0, 0, 1, 3)                
        self.snapGrid.addWidget(self.snapTopLeftPB,        1, 0, 1, 1)
        self.snapGrid.addWidget(self.snapTopPB,            1, 1, 1, 1)
        self.snapGrid.addWidget(self.snapTopRightPB,       1, 2, 1, 1)

        self.snapGrid.addWidget(self.snapLeftPB,           2, 0, 1, 1)
        self.snapGrid.addWidget(self.snapDummyPB,          2, 1, 1, 1)
        self.snapGrid.addWidget(self.snapRightPB,          2, 2, 1, 1)
        
        self.snapGrid.addWidget(self.snapBottomLeftPB,     3, 0, 1, 1)
        self.snapGrid.addWidget(self.snapBottomPB,         3, 1, 1, 1)
        self.snapGrid.addWidget(self.snapBottomRightPB,    3, 2, 1, 1)
        self.snapGrid.setRowStretch(4, 1)


        self.rotateGrid.addWidget(self.rotationLB,         0, 0, 1, 1)  
        self.rotateGrid.addWidget(self.rotateCCW90PB,      1, 0, 1, 1)
        self.rotateGrid.addWidget(self.rotateCW90PB,       2, 0, 1, 1)
        self.rotateGrid.addWidget(self.flipHorizontalPB,   3, 0, 1, 1)     
        self.rotateGrid.addWidget(self.flipVerticalPB,     4, 0, 1, 1)
        self.rotateGrid.setRowStretch(5, 1)
    
     
        self.boolGrid.addWidget(self.booleanLB,            0, 0, 1, 1)     
        self.boolGrid.addWidget(self.booleanMergePB,       1, 0, 1, 1)
        self.boolGrid.addWidget(self.booleanIntersectPB,   2, 0, 1, 1)
        self.boolGrid.addWidget(self.booleanSubstractPB,   3, 0, 1, 1)     
        self.boolGrid.addWidget(self.booleanSeperatePB,    4, 0, 1, 1)
        self.boolGrid.setRowStretch(5, 1)        


        self.distGrid.addWidget(self.distributeLB,         0, 0, 1, 1)
        self.distGrid.addWidget(self.distributeHPB,        1, 0, 1, 1)
        self.distGrid.addWidget(self.distributeVPB,        2, 0, 1, 1)
        self.distGrid.setRowStretch(3, 1) 

        self.utilGrid.addWidget(self.utilLB,               0, 0, 1, 1)
        self.utilGrid.addWidget(self.drawShadowPB,         1, 0, 1, 1)
        self.utilGrid.setRowStretch(2, 1)         
                
        self.configGrid.addWidget(self.configLB,           0, 0, 1, 8)
        self.configGrid.addWidget(self.configUseVisCB,     1, 0, 1, 4)
        self.configGrid.addWidget(self.configUseAnnoCB,    2, 0, 1, 4)
        self.configGrid.addWidget(self.configRotEachCB,    1, 3, 1, 4)
        self.configGrid.addWidget(self.donePB,             2, 7, 1, 1)
        
        uiDict = {
            self.alignGrid  : alignUI,
            self.snapGrid   : snapUI, 
            self.rotateGrid : rotateUI, 
            self.boolGrid   : booleanUI, 
            self.distGrid   : distributeUI,
            self.utilGrid   : utilUI
        }
        
        uiCount = 0
        for ui in uiDict:
            if uiDict[ui]:
                self.grid.addLayout(ui, 0, uiCount * 2, 1, 1)
                self.grid.setColumnMinimumWidth((uiCount * 2) + 1 , categorySpacing)
                uiCount += 1
                 
        self.grid.addLayout(self.configGrid,1, 0, 1, (uiCount * 2))        
                   
        self.grid.setHorizontalSpacing(2)
        self.grid.setVerticalSpacing(2)
        self.setLayout(self.grid)
        self.setWindowFlags(pya.Qt.WindowStaysOnTopHint)
        self.setWindowTitle ("Align Tool")

    def dummy(self):
        pass
        
    def selectedAnnotationBox(self):
        layoutView = mainWindow.current_view()
        unit       = 1/layoutView.active_cellview().layout().dbu
        box        = pya.DBox()
        for a in layoutView.each_annotation_selected():
            box += a.box()
        return pya.Box() if box.empty() else pya.Box(box.p1*unit,box.p2*unit)
        
    def selectedShapes(self):
        layoutView = mainWindow.current_view()  
        return sorted([s for s in layoutView.each_object_selected()], key=lambda s: s.seq)
        
    def rotateAbout(self, o, rotate = 0, rx = 0, ry = 0, flipH = False, flipV = False):
        item      = (o.inst() if o.is_cell_inst() else o.shape)
        cx, cy    = item.bbox().center().x, item.bbox().center().y
        tx, ty    = o.trans().disp.x, o.trans().disp.y
        mirror    = False
        mirror    = not(mirror) if flipV else mirror
        mirror    = not(mirror) if flipH else mirror
        rotate    = rotate + 180 if flipH else rotate
        
        item.transform(pya.Trans(  tx - rx,  ty - ry))
        item.transform(pya.ICplxTrans(1, rotate, mirror, 0, 0))
        item.transform(pya.Trans(  -tx + rx,  -ty + ry))

        
    def rotateFlipShape(self, rotate = 0, flipH = False, flipV = False, applyEach = False):
        layoutView = mainWindow.current_view()  
        layoutView.transaction("Rotation %.2f %s%s" % (rotate, ("H" if flipH else ""), ("V" if flipH else "")))
        try:
            if applyEach:
                for o in self.selectedShapes():
                    item      = (o.inst() if o.is_cell_inst() else o.shape)
                    cx, cy    = item.bbox().center().x, item.bbox().center().y
                    tx, ty    = o.trans().disp.x, o.trans().disp.y
                    self.rotateAbout(o, rotate, (cx + tx), (cy + ty), flipH, flipV)
                    
            else:
                groupBox = pya.Box()  
                for o in self.selectedShapes():
                    item      = (o.inst()if o.is_cell_inst() else o.shape)
                    groupBox += item.bbox().transformed(pya.Trans(o.trans().disp.x, o.trans().disp.y))

                groupCenter = groupBox.center()
                for o in self.selectedShapes():
                    self.rotateAbout(o, rotate, groupCenter.x, groupCenter.y, flipH, flipV)

        finally:
            layoutView.commit()
            
    def visibleLayers(self):
        layoutView = mainWindow.current_view()  
        return [    layerProp.layer_index() for layerProp in layoutView.each_layer() if layerProp.visible]

    def allowAnnoAlign(self):
        return self.configUseAnnoCB.isChecked()
        
    def useVisibleLayers(self):
        return self.configUseVisCB.isChecked()
        
    def rotateByEachCenter(self):
        return self.configRotEachCB.isChecked()
    
    def visibleBBox(self, o, useVisibleLayers = False):
        box = pya.Box()

        if useVisibleLayers and o.is_cell_inst():
            for layer_index in self.visibleLayers():
                box += o.inst().bbox(layer_index)
        else:
            box = (o.inst() if o.is_cell_inst() else o.shape).bbox()   
        return box.transformed(o.trans())  
         
    def instVisibleBBox(self, inst, useVisibleLayers = False):    
        box = pya.Box()      
        if useVisibleLayers:
            for layer_index in self.visibleLayers():
                box += inst.bbox(layer_index)
        else:
            box = inst.bbox()   
        
        return box               

    def distrubute(self, distributeH = False, distributeV = False, centerPitch = True, useVisibleLayers = False):
        layoutView    = mainWindow.current_view()  
        sortedShapesH = sorted(self.selectedShapes(), key = lambda o : self.visibleBBox(o, useVisibleLayers).center().x)
        sortedShapesV = sorted(self.selectedShapes(), key = lambda o : self.visibleBBox(o, useVisibleLayers).center().y)

        oFirstH       = sortedShapesH[ 0]
        oLastH        = sortedShapesH[-1]
        oFirstV       = sortedShapesV[ 0]
        oLastV        = sortedShapesV[-1]       
        oFirstBoxH    = self.visibleBBox(oFirstH, useVisibleLayers)
        oLastBoxH     = self.visibleBBox(oLastH,  useVisibleLayers)
        oFirstBoxV    = self.visibleBBox(oFirstV, useVisibleLayers)
        oLastBoxV     = self.visibleBBox(oLastV,  useVisibleLayers)
        oFirstCX      = oFirstBoxH.center().x
        oLastCX       = oLastBoxH.center().x
        oFirstCY      = oFirstBoxV.center().y
        oLastCY       = oLastBoxV.center().y
        objCount      = len(sortedShapesH)
        sepprationH   = int((oLastCX - oFirstCX)/(objCount-1))
        sepprationV   = int((oLastCY - oFirstCY)/(objCount-1))
        

        layoutView.transaction("ditribute %s%s" % (("H" if distributeH else ""), ("V" if distributeV else "")))
        try:
            if distributeH:
                for index, o in enumerate(sortedShapesH):
                    item   = (o.inst() if o.is_cell_inst() else o.shape)
                    box    = self.visibleBBox(o,   useVisibleLayers)
                    shiftH = oFirstCX + (index * sepprationH) - box.center().x
                    item.transform(pya.Trans(shiftH, 0))
                
            if distributeV:
                for index, o in enumerate(sortedShapesV):
                    item   = (o.inst() if o.is_cell_inst() else o.shape)
                    box    = self.visibleBBox(o,   useVisibleLayers)
                    shiftV = oFirstCY + (index * sepprationV) - box.center().y
                    item.transform(pya.Trans(0, shiftV))
                
        finally:
            layoutView.commit()

                
    def distrubuteH(self, centerPitch = True, useVisibleLayers = False):
        self.distrubute(distributeH = True, distributeV = False, centerPitch = centerPitch, useVisibleLayers = useVisibleLayers)
        
        
    def distrubuteV(self, centerPitch = True, useVisibleLayers = False):           
        self.distrubute(distributeH = False, distributeV = True, centerPitch = centerPitch, useVisibleLayers = useVisibleLayers)
    
    def translateGlobal(self, o, x, y):
        otrans = o.trans()
        invert = otrans.inverted() 
        move   = pya.Trans(x, y)
        revert = otrans
        return (invert * move * revert)

    def alignSnap(self, transText, useVisibleLayers = False, alignAnnotation = True):
        firstBox   = pya.Box() if not(alignAnnotation) else self.selectedAnnotationBox()
        layoutView = mainWindow.current_view()  
        unit       = layoutView.active_cellview().layout().dbu
        layoutView.transaction(transText)
        try:
            for o in self.selectedShapes(): 
                
                if firstBox.empty():
                    firstBox  = self.visibleBBox(o, useVisibleLayers)
                else:
                    secondBox = self.visibleBBox(o, useVisibleLayers)
                                            
                    transXAlignLeft   = firstBox.left       - secondBox.left       
                    transXAlignCenter = firstBox.center().x - secondBox.center().x
                    transXAlignright  = firstBox.right      - secondBox.right      
                    
                    transYAlignTop    = firstBox.top        - secondBox.top        
                    transYAlignMiddle = firstBox.center().y - secondBox.center().y 
                    transYAlignBottom = firstBox.bottom     - secondBox.bottom     
    
                    transXSnapLeft    = firstBox.left       - secondBox.right      
                    transXSnapRight   = firstBox.right      - secondBox.left       
                    
                    transYSnapTop     = firstBox.top        - secondBox.bottom     
                    transYSnapBottom  = firstBox.bottom     - secondBox.top        
                       
                    transDict = {
                        "alignTopLeft"      : self.translateGlobal( o, transXAlignLeft,   transYAlignTop),
                        "alignTopCenter"    : self.translateGlobal( o, transXAlignCenter, transYAlignTop),
                        "alignTopRight"     : self.translateGlobal( o, transXAlignright,  transYAlignTop),
    
                        "alignMiddleLeft"   : self.translateGlobal( o, transXAlignLeft,   transYAlignMiddle),
                        "alignMiddleCenter" : self.translateGlobal( o, transXAlignCenter, transYAlignMiddle),
                        "alignMiddleRight"  : self.translateGlobal( o, transXAlignright,  transYAlignMiddle),
                        
                        "alignBottomLeft"   : self.translateGlobal( o, transXAlignLeft,   transYAlignBottom),
                        "alignBottomCenter" : self.translateGlobal( o, transXAlignCenter, transYAlignBottom),
                        "alignBottomRight"  : self.translateGlobal( o, transXAlignright,  transYAlignBottom),
                                      
                        "alignTop"          : self.translateGlobal( o, 0,                 transYAlignTop),                    
                        "alignMiddle"       : self.translateGlobal( o, 0,                 transYAlignMiddle),
                        "alignBottom"       : self.translateGlobal( o, 0,                 transYAlignBottom),
                        
                        "alignLeft"         : self.translateGlobal( o, transXAlignLeft,   0),
                        "alignCenter"       : self.translateGlobal( o, transXAlignCenter, 0),
                        "alignRight"        : self.translateGlobal( o, transXAlignright,  0),
                        
                        "snapTop"           : self.translateGlobal( o, 0,                 transYSnapTop),
                        "snapBottom"        : self.translateGlobal( o, 0,                 transYSnapBottom),
                        
                        "snapLeft"          : self.translateGlobal( o, transXSnapLeft,    0),
                        "snapRight"         : self.translateGlobal( o, transXSnapRight,   0),
    
                        "snapTopLeft"       : self.translateGlobal( o, transXSnapLeft,    transYSnapTop),
                        "snapBottomLeft"    : self.translateGlobal( o, transXSnapLeft,    transYSnapBottom),
                        "snapTopRight"      : self.translateGlobal( o, transXSnapRight,   transYSnapTop),
                        "snapBottomRight"   : self.translateGlobal( o, transXSnapRight,   transYSnapBottom)              
                    }
                    (o.inst() if o.is_cell_inst() else o.shape).transform(transDict[transText])
   
        finally:
            layoutView.commit()
    
    
    def attemptGrabRuler(self):
        if self.grabRuler: 
            self.releaseTransRuler()
            self.releaseGrabShadows()
            
        else : 
            self.grabTransRuler()
            ruler  = self.grabRuler
            if ruler:
                vector = (ruler.p2-ruler.p1)
                self.grabSelectedShadow(vector.x, vector.y)

            
    def grabTransRuler(self):
        layoutView     = mainWindow.current_view()
        annotationList = list(layoutView.each_annotation_selected())
        if len(annotationList) == 1:
            ruler = annotationList[0]
            valid = [
                len(ruler.points) == 2,
                ruler.segments()  == 1,
                ruler.outline not in [
                    pya.Annotation.OutlineRadius, 
                    pya.Annotation.OutlineEllipse, 
                    pya.Annotation.OutlineAngle
                ],
            ]

            if all(valid):
                self.grabRuler     = ruler
                self.grabTheme     = {
                    "fmt"     : ruler.fmt, 
                    "outline" : ruler.outline, 
                    "style"   : ruler.style
                }
                
                ruler.fmt     = "move $X, $Y"
                ruler.outline = pya.Annotation.OutlineDiag
                ruler.style   = pya.Annotation.StyleArrowEnd
    
    def releaseTransRuler(self):
        if self.grabRuler: 
            self.grabRuler.fmt     = self.grabTheme["fmt"]
            self.grabRuler.outline = self.grabTheme["outline"]
            self.grabRuler.style   = self.grabTheme["style"]
            self.grabTheme         = {}
        self.grabRuler = None
        
        
    def transByRuler(self):        
        layoutView = mainWindow.current_view()
        unit       = layoutView.active_cellview().layout().dbu
        
        if self.grabRuler and self.selectedShapes():
            ruler  = self.grabRuler
            vector = (ruler.p2-ruler.p1)
            x      = int(vector.x / unit)
            y      = int(vector.y / unit)
            trans  = pya.DTrans(ruler.p2-ruler.p1)
            layoutView.transaction("move by ruler")
            try:
                for o in self.selectedShapes():    
                    trans = self.translateGlobal(o, x, y)
                    (o.inst() if o.is_cell_inst() else o.shape).transform(trans)     
            finally:
                layoutView.commit()
        else: 
            loc = self.transByRulerPB.pos + self.pos
            pya.QToolTip().showText(
                loc,
                "Select one linear Ruler for shape translation\n"+ \
                "Select atleast one object for shape translation."
            ) 
    def drawShadow(self, points = []):
        shadow = pya.Annotation()
        if points:
            if not(points[0] == points[-1]):
                points.append(points[0])
            shadow.outline = pya.Annotation.OutlineDiag
            shadow.style   = pya.Annotation.StyleLine
            shadow.fmt     = ""
            shadow.points  = points
        return shadow
        
        
    def grabShapeShadow(self, o): 
        layoutView  = mainWindow.current_view()
        unit        = layoutView.active_cellview().layout().dbu
        box         = (o.inst() if o.is_cell_inst() else o.shape).bbox()
        shapeShadow = pya.Annotation()
        boxShadow   = pya.Annotation()
        

        if not(o.is_cell_inst()):
            box         = box.transformed(o.trans())
            shapePtList = [pya.DPoint(p.x * unit, p.y * unit) for p in o.shape.polygon.each_point_hull()]
            shapeShadow = self.drawShadow(shapePtList)
            shapeShadow = shapeShadow.transformed(o.trans().to_itrans(unit))
            
        boxPtList = [
            pya.DPoint(box.p1.x * unit, box.p1.y * unit), 
            pya.DPoint(box.p2.x * unit, box.p1.y * unit), 
            pya.DPoint(box.p2.x * unit, box.p2.y * unit), 
            pya.DPoint(box.p1.x * unit, box.p2.y * unit)
        ]
        
        boxShadow = self.drawShadow(boxPtList)
        return [boxShadow] if o.is_cell_inst() else [shapeShadow]
    
    def grabSelectedShadow(self, offset_x=0, offset_y=0): 
        layoutView = mainWindow.current_view()
        shapeArray = self.selectedShapes()

        if shapeArray:
            for o in shapeArray:
                for shadow in self.grabShapeShadow(o):
                    shadow = shadow.transformed(pya.DCplxTrans(1, 0, False, offset_x, offset_y))
                    self.grabShadows.append(shadow)
                    layoutView.insert_annotation(shadow)


    def releaseGrabShadows(self):
        layoutView = mainWindow.current_view()
        for shadow in self.grabShadows:
            layoutView.erase_annotation(shadow.id())
            shadow.detach()
            shadow.delete()
        self.grabShadows = []

                    
    def keyPressEvent(self, event):
        if event.type() == pya.QEvent.KeyPress:
            if event.key() in (pya.Qt.Key_Return, pya.Qt.Key_Escape, pya.Qt.Key_Enter):
                self.close()
           
    
        
class TitleLB(pya.QLabel):
    def __init__(self, title, parent = None):
        super(TitleLB, self).__init__(title)    
        self.setAlignment(pya.Qt.AlignCenter)
        self.setFixedHeight(20)
        self.setStyleSheet(
        """
            QLabel{
                background-color : #dfdfdf;
            }
        """
        )
 
        

class SquarePB(pya.QPushButton):

    def __init__(self, icon = None, bindFunction = None, hoverFunction = None, parent = None):
        super(SquarePB, self).__init__()    
        self.setFixedSize(50, 50)    
        self.setStyleSheet(
        """
            QPushButton {
                background: #efefef;
                border: 1px solid transparent;
                border-radius: 2px;
            }
            
            QPushButton::hover {
                border: 1px solid #33ccaa;
            }
            
            QPushButton::pressed {
                border: 1px solid #009966;
            }
        """
        )

        if icon:
            self.setIcon(pya.QIcon(icon))
            self.setIconSize(pya.QSize(40, 40))
            
        if bindFunction:
            self.clicked(bindFunction)
        self.hoverFunction = hoverFunction

    def enterEvent(self, event):
        if not(self.hoverFunction) == None : self.hoverFunction()
        
    def leaveEvent(self, event):
        if not(self.hoverFunction) == None : self.hoverFunction()

        
mainWindow    = pya.Application.instance().main_window()
screenRect    = pya.QApplication.desktop().screenGeometry()

def callAlignWidget():
    layoutView = mainWindow.current_view()  
    if layoutView:
        height        = screenRect.height
        width         = screenRect.width
        widget        = AlignWidget()

        widget.show()
        x = mainWindow.pos.x + 25
        y = mainWindow.pos.y + mainWindow.height - widget.height - 50
        
        widget.move(pya.QPoint(x, y))
    else:
        pass
              
def bindMenu():
    menu      = pya.Application.instance().main_window().menu()
    act       = pya.Action()
    act.title = "Align Tool"
    menu.insert_item("tools_menu.end", "Align Tool", act)
    act.on_triggered(lambda : callAlignWidget())
    
bindMenu()</text>
</klayout-macro>
